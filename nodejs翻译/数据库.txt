笛卡尔积：两个集合X，Y，X*Y（即笛卡尔积表示法）是所有可能的*有序对*组成的集合，其中有序对的第一个对象是X的成员，第二个对象是Y的成员。
K元关系定义：在集合X1，X2，...，XK上的关系L是指集合的笛卡尔积的*子集*。因此，K元关系就是K元祖的集合。
在数学上将关系定义为一系列域上的笛卡尔积的子集，因此关系应该是一个集合（需要复习集合论了）。
　  
从对"表"的定义来看，表也是一系列域上的笛卡尔积的子集（1NF规定了元组不可再分），这一定义与前面对关系的定义几乎是完全相符的。
从目前来看，关系和表的区别在于我们给表中的属性赋予了名称，而关系则没有。而最为重要的区别在于在实际当中，
表中允许有重复的行（表实际上是一个多重集的概念），而在关系中则不允许有重复的元组（因为关系是一个集合）。

范式：1、有级别，1NF,2NF,3NF,BCNF,4NF,5NF
     2、定义：表示一个关系内部属性之间的联系的合理化成都。
     
1NF：符合1NF的关系，它的每一个属性都不可再分。
表1：
-------------------------------------------------------
编号   |  产品  |    进货      |     销售     |  备注
      |       |----------------------------|
      |       | 数量  |  单价  | 数量 |  单价 |
-------------------------------------------------------
      |       |       |       |     |      |
-------------------------------------------------------
表1中的进货和销售进行了属性分割，不符合1NF。
1NF是所有关系型数据库的最基本要求。修改表1符合1NF：
表2：
------------------------------------------------------------------------
编号   |   产品  |  进货数量  |  进货单价  |  销售数量  | 销售单价  |   备注  |
------------------------------------------------------------------------
      |        |           |           |           |          |        |
------------------------------------------------------------------------
但是仅仅按照1NF设计数据库，会产生过大的数据冗余问题，插入异常，删除异常，修改异常的问题。例如:
表3：
-------------------------------------------------------------------------
     学号   |   姓名  |   系名  |   系主任  |   课名    |   分数      |
-------------------------------------------------------------------------
20160601   |   李明  |   经济系 |   王强   |  高数     |   95        |
-------------------------------------------------------------------------
20160601   |   李明  |   经济系 |   王强   |  英语     |   87        |
-------------------------------------------------------------------------
20160601   |   李明  |   经济系 |   王强   |  化学     |   76        |
-------------------------------------------------------------------------
20160602   |   张霞  |   经济系 |   王强   |  高数     |   87        |
-------------------------------------------------------------------------
20160602   |   张霞  |   经济系 |   王强   |  英语     |   80        |
-------------------------------------------------------------------------
20160602   |   张霞  |   经济系 |   王强   |  化学     |   89        |
-------------------------------------------------------------------------
每一名学生的学号、姓名、系名、系主任等数据多次重复出现。-------数据冗余过大
假如学校新建一个系，但目前没有学生，系主任和系名单独插入就会出现异常  -------插入异常
假如删除一个系的所有学生，那么系主任和系名数据也会消失，不合理    --------删除异常
假如学生转系，需要修改三条记录中系名和系主任名的数据            ---------修改异常

2NF：符合1NF的基础上，消除了非主属性对于码的**部分依赖函数**。
    函数依赖：若在一张表中，在属性（属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作X->Y。
            也就是说，如果记录的X值相同，那么他们的Y值一定相同。
    例如表3，学号相同对应的姓名也都相同，就可以说姓名函数依赖于学号，学号->姓名，但是由于同名的问题，反过来就不行了。
            表中其他的函数依赖关系还有：
                系名->系主任
                学号->系主任
                学号->姓名
                (学号、课名)->分数
            以下依赖关系不成立:
                学号->课名
                学号->分数
                课名->系主任
                (学号、课名)->姓名
            ***完全函数依赖***
                在一张表中，若X->Y，且对于X的任何一个子集（假如属性组包含多个属性），X'->Y不成立，就称为Y对于X完全函数依赖，记作XF->Y(F应该在箭头上方)。
                即：  F
                   X--->Y；
                例如：
                    学号 F->姓名
                   （学号、课名） F->分数

            ***部分函数依赖***
                假如Y依赖函数X，但同时又不完全依赖于X，就称Y部分函数依赖于X，记作：X P->Y
                例如：
                  （学号、课名） F->姓名     ----其实学号就可以确定姓名了 
            ***传递函数依赖***
                假如Z函数依赖于Y，且Y函数依赖于X（严格讲：X不包含于Y，且Y不函数依赖于Z的前提条件），那么久称Z传递函数依赖于X，记作X T->Z。
                
           *** 码 ***
                设K为某表中的一个属性或属性组，若除K之外的所有属性都**完全**函数依赖于K，那么就称K为候选码，简称为码。可以这样理解：假如当K确定的情况下，
                该表除K之外的所有属性的值也就随之确定，那么K就是码。一张表中可以有超过一个码。（实际中为了应用方便，通常选择其中的一个码作为主码）
                例如：
                    对于表3，（学号、课名）这个属性组就是码
                包含在任何一个码中的属性就是主属性。
            判断表3是否符合2NF，实际就是看数据表中是否存在非主属性对于码的部分函数依赖。若存在，则不符合。判断方法：
                ***  找出数据表中所有的码
                ***  根据码，找出所有主属性
                ***  除去表中的所有主属性，剩下的就都是非主属性了
                ***  查看是否存在非主属性码对码的部分函数依赖。
                
                表3的解决方案：
                ***  1、查看所有单个属性组，当他的值确定了，是否剩下的所有属性值都能确定。
                     2、查看所有2个属性组，当他的值确定了，是否剩下的所有属性值都能确定。
                     3、、、、、、、
                     4、查看所有6个属性组，当他的值确定了，是否剩下的所有属性值都能确定。
                     记住一点，如果A是码，那么所有的（A，B），（A，B，C）等等都不再是码了。
                     所有函数依赖如下图所示：
                     ---------------------------------------------------------------------------
                     学号                    |       课名                   ----- F ---->分数
                     ---------------------------------------------------------------------------
                       F|      F|       F|           
                      姓名     系名--F-->系主任
                     ---------------------------------------------------------------------------
                     可以看出表3的码就是(学号、课名)；主属性就是学号和课名；非主属性就是姓名、系名、系主任和分数；确定非主属性对主属性的部分函数依赖关系
                     消除部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这就是模式分解。
                     模式分解方法并不唯一：
                     
                     
          2NF消除了数据冗余过大和修改异常的问题，但是对删除和插入异常无助。        
3NF:在2NF的基础之上，消除了非主属性对于码的传递函数依赖。也就是说如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。
          3NF消除了删除和插入异常的问题。
          由此可见，符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。
          当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，（什么意思？？？）
          但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。
          
          ********  事实证明，即使符合了3NF，在某些实际情况下，也会出现类似的插入、修改和删除异常问题，然后就出现了BCNF。
          ********  原因就在于：存在着主属性对于码的部分函数依赖于传递依赖。
BCNF:在3NF的基础上消除主属性对于码的部分函数依赖。

                     