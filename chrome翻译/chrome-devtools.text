翻译目录：https://developers.google.com/web/tools/chrome-devtools/iterate/?hl=en
----------------------------------------------------------------------------
1 Tools 工具
----------------------------------------------------------------------------
    ----------------------------
    1.1 Getting Started 入门
    ----------------------------
        ----------------
        1.1.1 ......
        ----------------
        ----------------
        1.1.n......
        ----------------
    ----------------------------
    1.2 Chrome DevTools Chrome开发者工具
    ----------------------------
Chrome 开发者工具（DevTools）是一系列谷歌浏览器内置的网站制作和调试工具集。使用DevTools开发工具进行迭代，调试和监测站点。ChromeCanary最新拥有最新版的开发者工具。
菜单栏->更多工具(more tools)->开发者工具(developer tools)，打开开发者工具面板，或者使用右键选择‘检查（Inspect）’选项打开开发者工具面板，或者使用快捷键Ctrl+Shift+I(Windows)或Cmd+Opt+I（Mac）打开开发者面板。
初识命令面板：
ELEMENTS（元素）：在元素面板界面，通过直接操作DOM和CSS，对网站设计和布局进行迭代。

CONSOLE（控制台）：在开发过程中，使用控制台记录日志，或者通过它与页面上的JavaScript代码交互。
SOURCES（源文件）：通过源文件面板上的断点对JavaScript代码进行调试，或者通过工作区连接你本地文件并使用开发者工具实时编辑。
NETWORK（网络）：通过网络面板，可以对页面请求和资源加载进行深入分析，并优化你的网页加载性能。
TIMELINE（时间轴）：使用时间轴记录和探索网站生命周期中所发生的各种事件，从而提高网页运行时性能。
PROFILES（分析面板）：通过分析面板，你可以获取比时间轴面板更多的信息，比如跟踪内存泄漏。
RESOURCE（资源）：使用资源面板来检查所有的已加载资源，包括IndexedDB或者WebSQL数据库，本地和会话存储，cookies，应用缓存，图片，字体和样式表。
SECURITY（安全）：使用安全面板调试混合内容问题，证书问题以及其他更多的信息。
        -----------------------
        1.2.1 Iterate 迭代
        -----------------------
            ------------------------------------------------------------------------------------------------------------------
            1.2.1.1 Inspect and Edit Pages and Styles
            ------------------------------------------------------------------------------------------------------------------
            ------------------------------------------------------------------------------------------------------------------
            1.2.1.2 Manage Your Local Data Resources
            ------------------------------------------------------------------------------------------------------------------
            ------------------------------------------------------------------------------------------------------------------
            1.2.1.3 Simulate Mobile Devices with Device Mode
            ------------------------------------------------------------------------------------------------------------------
        -----------------------
        1.2.2 Debug 调试
        -----------------------
            ------------------------------------------------------------------------------------------------------------------
            1.2.2.1 Remote Debugging
            ------------------------------------------------------------------------------------------------------------------
            ------------------------------------------------------------------------------------------------------------------
            1.2.2.2 Using Javascript Snippets
            ------------------------------------------------------------------------------------------------------------------
            ------------------------------------------------------------------------------------------------------------------
            1.2.2.3 Debug Obfuscated Code
            ------------------------------------------------------------------------------------------------------------------
            ------------------------------------------------------------------------------------------------------------------
            1.2.2.4 Debug with Breakpoints
            ------------------------------------------------------------------------------------------------------------------
            ------------------------------------------------------------------------------------------------------------------
            1.2.2.5 Understand security issures
            ------------------------------------------------------------------------------------------------------------------
            ------------------------------------------------------------------------------------------------------------------
            1.2.2.6 Using the console
            ------------------------------------------------------------------------------------------------------------------
            ------------------------------------------------------------------------------------------------------------------
            1.2.2.7 Interact from Commond Line
            ------------------------------------------------------------------------------------------------------------------
            ------------------------------------------------------------------------------------------------------------------
            1.2.2.8 Watch variables in Sources Profile
            ------------------------------------------------------------------------------------------------------------------
        -----------------------
        1.2.3 Profile 监测（性能）
        -----------------------
            ------------------------------------------------
            1.2.3.1 How to look at Performance   如何监测性能
            ------------------------------------------------
                不要简单的认为提高性能就是遵循一组该做和不该做的规则（该规则是指用于提高性能应该遵循的一些设计类的原则）那样简单。完全遵循规则是很简单就可以做到的，但规则是会变得。
            首先，你要关注用户的感受。用户对延迟的感受远远的要超过任何已制定的规则，一切规则都是为了给用户更好的额体验。
                RAIL(Responce,Animation,Idle,Load)是一个以用户为中心（user-centric）的性能模型,代表着响应(Responce),动画(Animation),空闲(Idle)和加载(Load)四个方面。
            接下来将学习如何使用chrome浏览器的监测工具根据RAIL模型测试性能。
                ----------------------------------------
                Topic1:    The RAIL Performance Model   RAIL性能模型
                ----------------------------------------
                    RAIL是一个以用户为中心的性能模型。在每一个web应用的生命周期中，都会包含这四个不同的方面，且每一方面性能提升的方式也不相同。
                    内容概述：
                        关注用户：最终目标不是为了让你的网站性能在特定设备上得到提升，而是让用户满意。
                        立即响应用户：要在100ms内获取用户的输入
                        单帧渲染要在16ms内完成，动画要连贯；用户不能发现有卡顿现象。
                        最大化主线程的空闲时间。
                        保持用户的活跃，在1000ms内完成用户交互。
                    -----------------------------
                    Focus on the user 关注用户体验
                    -----------------------------
                            让用户关注到你web应用的性能提升。用户的时间大部分花费在交互时等待网站响应，而不是网站加载。下面学习下用户对不通的延迟的感受：
                        延迟                       用户反应
                        0-16ms        因为常规设备屏幕刷新频率是60次/秒，窗口就要在该时间（0-16ms）内获取并显示一帧（数学计算：1000/60~=16''）。人类的视觉对运动
                                      十分敏感，无论是可变帧率或者是周期性帧率，当无法满足这一时间时，就会引起不好的视觉感受。
                        0-100ms       在该时间段内响应用户的交互，用户感觉是立即得到了响应。任何更长的时间，交互过程都会中断。
                        100-300ms     用户遇到轻微的明显延迟
                        300-1000ms    在该时间内，用户感觉这是一个持续进行中的任务的一部分。对于大多数web用户而言，网页加载或视图改变就是一个类似的任务（意味着等待时间长）。
                        1000+ms       超过1s的时间，用户就会失去耐心。
                        10000+ms      用户感到很慢，就会终止该任务，且可能不会再来。
                   --------------------------------------------------
                   Response:respond in under 100 ms 响应：在100ms内响应
                   --------------------------------------------------
                        如果你在100ms内响应用户输入，用户是感受不到延迟的。这条规则适用于任何输入操作，无论是点击按钮，切换表单控件还是启动动画。
                        如果你没有响应，交互连接就会中断，用户就会感觉到延迟。
                        立即响应用户请求是众所周知的做法，但并不是意味着你总能够恰当的使用。如果要在100ms内做些其他消耗较高的工作，但要注意不要阻塞用户操作。如果可能，请在后台完成高消耗任务。
                        对于超过500ms交互任务，总是会提供一些反馈。（不是太明白什么意思）
                        注意：对于用户触摸和滚动条的响应要在16ms内完成。
                   ------------------------------------------------------
                   Animation：render frames every 16ms 动画：每16ms渲染一帧
                   ------------------------------------------------------
                        动画不是网站必需的部分，web应用可以选择性加入动画。例如，滚动和触摸移动就是动画的一种。如果动画的帧率发生了变化，用户是能够感受出来的。你必需要在每秒渲染出60帧才能满足要求。
                    而且每一帧的产生都会经过一下步骤：
                                                JavaScript->Style->Layout->Paint->Composite
                    从纯数学角度来讲，每一帧都有16.66ms的渲染时间（1/60）。事实上，由于浏览器有额外的开销，真正的允许你动画渲染的时间大约只有10ms。
                        在高压力点下比如渲染动画，关键是少做事情，仅做必需的事情。只要可能，尽量充分利用100ms的响应时间做一些高消耗的任务，让你能够在帧率为60的屏幕上充分发挥。
                    更多信息，参考渲染性能板块。
                   --------------------
                   Idle:充分利用空闲时间
                   --------------------
                        利用空闲时间完成一些延后的任务。例如，保持预加载数据到最低限度，使您的程序快速加载，然后使用空闲时间加载余下的数据。延迟任务要组织成50ms的任务块。如果
                    某个用户开始交互，最高优先级应该对此作出回应。
                        为了在100ms内响应交互，程序必需每100ms将控制权返回给主线程，使程序可以执行像素管线渲染，响应用户输入等。50ms块任务既能确保任务完成，还能确保即时响应。
                   -------------------------------------------------------
                   Load:deliver content under 1000ms 加载：在1000ms内传输内容
                   -------------------------------------------------------
                        在1s内将你的网站加载完成。如果超出1s，用户的注意力就会降低，且使用网站功能的感受也会遭到破坏。你不需要在1s内加载完网站所有的东西以达到加载完成的用户体验。
                    你可以在启动渐进式渲染，而且可以在后台做一些其他额外的任务。将非主要任务延迟到空闲时间。
                   -------------------------------------------
                   Summary of key rail metrics RAIL关键指标概述
                   -------------------------------------------
                       使用chrome开发者工具中的时间轴(Timeline)记录用户的动作并依据RAIL模型指标评估你的网站性能。然后在记录中检测对应的RAIL指标，并做对比：
                       RAIL Step       Key Metric                                    User Actions
                        响应            输入延迟（从点击到绘制）小于100ms                用户点击图标或者按钮（打开导航菜单，点击组件）
                        响应            输入延迟（从点击到绘制）小于16ms                 用户拖拽页面，程序响应手指动作（拖拽页面刷新，滑动页面）
                        动画            输入延迟（从点击到绘制）小于100ms                用户初始化页面滚动条或者动画开始
                        动画            每一帧渲染（从JS到绘制）完成小于16ms             用户滚动页面或观看动画
                        空闲            主线程JS任务快不超过50ms                       用户没有交互动作。但是主线程有足够能力处理下一个用户的输入
                        加载            页面要在1000ms内达到可用状态（部分加载？）        用户加载页面且能看到主要内容
                        加载            当页面完全加载且能满足及时响应的目标              用户加载页面并进行交互动作（滚动或打开导航）
                    作者：Meggin Kearney
                         Meggin is Tech Write(技术作家)
                    译者：TigerWFH
                         TigerWFH is Developer  
                --------------------------------------------
                Topic2:    How to Use the Timeline Tool 如何使用时间轴工具
                --------------------------------------------
                    使用Chrome开发者工具的时间轴（Timeline）记录并分析你应用运行时的所有活动。时间轴是调查分析你应用的性能好坏的最好开端。
                    TL；DR
                    制作时间轴记录，然后分析页面加载完成或用户交互后发生的所有事件。
                    在概述窗口（Overview）查看FPS，CPU和网络请求。
                    点击火焰图（FlameChart）中的事件以查看详细信息。
                    放大记录中的某一部分便于分析。
                    -------------------------
                    时间轴上概述
                    -------------------------
                    时间轴面板包含了四个面板：
                        1、控制面板区域（Controls）：开始记录按钮、停止记录按钮、以及配置记录期间要记录的选项等按钮（相当于过滤器）。
                        2、Overview区域：页面性能的高度概括。
                        3、火焰图（FlameChart）区域：可视化的CPU堆栈跟踪。
                            你可能会看到火线图上有一些垂直的点线。其中，蓝色线代表DOMContentLoaded事件；绿色线代表第一次绘制时间；红色线代表加载事件。
                        4、详细信息区域：当选定一个事件，该区域显示该事件的详细信息。未选定事件，则显示选定事件帧（timeframe）的信息。

                    Overview区域：
                    包含三种图表:
                        1、FPS:帧率。绿色线条越高，帧率越高。FPS上方的红色方块表示长帧，这些长帧可能就会产生卡顿的现象。
                            （jank：超过一定的渲染时间，页面的渲染出现卡顿现象，这就是常说的jank）。
                        2、CPU：CPU资源。此区域的图表显示了是什么类型的事件消耗了CPU资源。
                        3、NET：每一种颜色的线条代表一种资源。线条越长，意味着获取该资源的消耗时间越长。线条较亮的亮部代表着资源等待时间（资源被请求到第一个字节被加载之间的时间），
                                线条较暗的暗部代表着传输时间（从第一字节下载到最后以字节下载完成的时间间隔）。
          
                        注释：  线条颜色如下注释：HTML文件是蓝色（blue）；Script文件是黄色（yellow）；Stylesheets文件是紫色（purple）；多媒体文件是绿色（green）；其他资源（miscellaneous resource）是灰色（gray）。
                    制作记录：
                        如何记录页面加载信息？首先，打开时间轴面板，打开你要记录的页面进行记录，然后重新加载页面。时间轴面板会自动记录页面重加载的所有信息。
                        如何记录与页面的交互信息？首先，打开时间轴面板，点击Record按钮或者使用快捷键Cmd+E（Mac）或者Ctrl+（Windows/Linux）开始记录交互信息。记录过程中Record按钮变为红色。
                        然后进行页面交互进行记录。通过再次点击Record按钮或者快捷键方式停止记录。
                        当记录完成，开发者工具（DevTools）能够自动列出你需要的信息部分并自动放大该区域信息供使用。
                    记录建议：
                        1、记录时间尽可能短：短记录更容易分析。
                        2、避免不需要的行为：不必要的行为（鼠标点击、网络加载等）和你想要记录和分析的活动事件是没有关系的。例如，如果你想要记录你点击登陆按钮后发生的事件时，也不要滚动页面，加载图片等等。
                        3、禁用浏览器缓存：当记录网络操作时，禁用浏览器缓存是一个很好地注意。
                        4、禁用扩展：chrome扩展会向你的应用的时间轴记录中添加无关的信息。在incognito模式下打开chrome或者创建一个新的chrome用户文件确保你的运行环境没有扩展。
                    查看记录详情：
                        当你在火焰图选定一个事件时，Details区域就会显示该事件更详细的信息。
                        一些tabs页，比如summary适用于所有类型的事件；另一些仅仅使用指定类型的事件。具体详情，参考相关资料。
                    记录过程中获取截图：
                        当页面加载，时间轴面板可以捕获截图。该特性就是幻灯片图形。
                        选中命令区的ScreenShots按钮，开始记录，即可获取页面截图。并显示在Overview区域下方。
                        将鼠标悬浮在截图上或者Overview区，查看记录中放大的截图。左右移动鼠标，模拟动态效果。
                    JavaScript文件：
                        选中JS Profile，开始记录。时间轴会记录脚本的堆栈调用信息。当选中该选项，火焰图中会显示所有被调用过的JS函数。
                    绘制介绍：
                        选中Paint按钮，可以记录先关的绘制事件信息，进入更深入的分析。当绘制信息捕获后，点击绘制事件，在详情区中会显示一个tab页PaintProfile，显示该事件的详细信息。
                    渲染设置：
                        打开开发者菜单，选择更多工具中的渲染设置选项进行设置。这有助于调试渲染产生的问题。渲染设置按钮在console的旁边，也是一个tab页面。
                    查询记录：
                        如果你仅仅想单独关注一类事件，比如你想要查看每一个 解析HTML 事件的详情。按下Cmd+（Mac）或者Ctrl+e（widnows/linux）快捷键，此时时间轴会出现搜索工具栏，输入事件类型
                        的名字，比如Event，你就可以查看到对应的信息。搜索工具栏仅用于当前选定的时间段（timeframe），不会包含选定时间段以外的任何事件。通过上下箭头按时间移动搜索结果。所以，第一个
                        结果就是当前时间段中的第一个事件，最后的结果就是最后的事件。每一次点击上下箭头，就会选中一个新事件，你可以在详情区域查看对应的事件详情。点击箭头就相当于直接点击火焰图
                        中的事件，效果是一致的。
                    放大时间轴区域：
                        你可以放大记录的一部分进行细致的分析。通过Overview区域放大记录的某一部分。缩放之后，火焰图会自动匹配对应的区域。通过鼠标或者快捷键进行缩放操作。
                        保存加载记录：
                        在Overview或者火焰图区域点击鼠标右键显示保存和加载菜单，通过菜单命令进行对应的操作。
                --------------------------------------------------
                Topic3:   Timeline Event Reference 时间轴事件参考资料
                --------------------------------------------------
                    时间轴事件模式描述了记录期间触发的所有事件。通过时间轴事件参考资料学习更多有关时间轴事件类型的知识。
                  ---------------------------------------------------
                  Common timeline event properties 常规时间轴事件属性
                  ---------------------------------------------------
                      某些细节存在于所有类型的事件，而有些细节则存在于特定类型的事件。该节列举了不通类型时间的公共属性。特定类型事件的特殊属性在相关的特定类型事件下列举。
                      公共属性：
                      
                      Property                             Whenis it shown
                      Aggregated time                      对于含有嵌套事件（nested events）的事件，每一类别事件消耗的时间
                      Call stack                           对于含有子事件（child events)的事件，每一类消耗的时间
                      CPU time                             记录事件消耗的CPU时间
                      Details                              关于事件的其他详细信息
                      Duration（at time-stamp）             事件以及该事件的子事件完成消耗的时间；时间戳是事件发生的时间点，和记录开始时间相关。
                      Self time                            事件本身消耗的时间（不包括子事件）
                      Used Heap Size                       当记录事件时，程序会消耗大量的内存，根据上次采样数据，三角（delta，+/-）会反映出消耗内存大小。（不太理解）
                  -----------------------
                  Loading events 加载事件
                  -----------------------
                      该区域列举了加载范围内的事件及其属性。
                      
                      Event                             Description
                      Parse HTML                        Chrome执行HTML解析器对HTML进行解析
                      Finish Loading                    网络请求完成
                      Receive Data                      接收请求返回的数据。会产生一个或多个接收数据事件。
                      Receive Response                  来自请求的最初的HTTP响应
                      Send Request                      发送网络请求
                      
                      加载事件的属性：
                      
                      Property                           Description
                      Resource                           请求资源的URL
                      Preview                            请求资源的预览(只有图像资源可以预览)
                      Request Method                     HTTP请求方法(Get或者POST)
                      Status Code                        HTTP响应码
                      MIME Type                          请求资源的MIME类型
                      Encoded Data Length                以字节为单位，请求资源的长度
                  --------------------------
                  Scripting events 脚本事件
                  --------------------------
                      该区域列举了脚本范围内的事件及其属性
                      
                      Event                               Description
                      Animation Frame Fired               预定的动画帧激活，其回调函数被调用
                      Cancel Animation Frame              取消预定的动画帧          
                      GC Event                            发生垃圾回收（内存回收）
                      DOMContentLoaded                    浏览器触发DOMContentLoaded事件。当页面的所有DOM内容都加载完成时触发。
                      Evalute Script                      脚本评估。（不太理解）
                      Event                               一个JS脚本（例如mousedown或者key）
                      Function Call                       顶级JS函数被调用（只有当浏览器进入JS引擎）
                      Install Timer                       使用setInterval()或者setTimeout()创建定时器
                      Request Animation Frame             requestAnimationFrame()函数被调用，安排新的动画帧
                      Remove Timer                        删除已安装的定时器
                      Time                                脚本调用console.time()
                      Time End                            脚本调用console.timeEnd()
                      Time Fired                          使用setInterval()或settimeout()安装的定时器被触发
                      XHR Ready State Change              XMLHTTPRequest准备状态改变
                      XHR Load                            XMLHTTPRequest完成加载
                      
                      脚本事件属性
                      Property                              Description
                      Timer ID                                定时器ID
                      Timeout                                 定时器指定的超时
                      Repeats                                 布尔值，指明定时器是否重复
                      Function Call                           调用函数
                  ------------------------
                  Rendering events 渲染事件
                  ------------------------
                      该区列举了渲染范围内的事件及其属性。
                      
                      Event                                   Description
                      Invalidate layout                       DOM变化引起的页面布局失效
                      Layout                                  执行页面布局
                      Recalculate style                       chrome重新计算元素风格
                      ScrollS                                 滚动嵌套视图内容
                      
                      渲染事件属性：
                      Property                                  Description
                      Layout invalidate                         在布局记录中，提供引起布局无效的代码的堆栈跟踪
                      Nodes that need layout                    在布局记录中，重布局开始前已被标记的重布局结点总数。这些节点一般是开发者通过代码设定的无效，并添向重布局根路径添加路径。（是添加指向无效结点的路径吗？）
                      Layout tree size                          在布局记录中，重布局根结点（chrome开始重布局的那个结点）下所有结点个数总和
                      Layout scope                              可能是指整个文档也可能是文档中的一部分（例如重布局那部分）
                      Elements affected                         在重新计算样式记录中，样式冲计算影响的结点元素总数                         
                      Styles invalidated                        在重新计算样式记录中，显示引起样式无效的的代码的堆栈跟踪
                  -----------------------
                  Painting events 绘制事件
                  -----------------------
                      该部分提供了绘制范围内的事件及其属性。
                      
                      Event                                    Description
                      Composite Layers                         Chrome的渲染引擎合成图像层
                      Image Decode                             解码一个图像资源
                      Image Resize                             在原尺寸的基础上调整图像大小
                      Paint                                    合成图像层被绘制到显示区域。鼠标悬停在绘制记录上会使更新区域高亮显示。
                      
                      绘制事件属性
                      Property                                 Description
                      Location                                 绘制矩形的x,y坐标
                      Dimensions                               绘制区域的宽和高
                  Authors：Meggin Kearney      Meggin is a Tech Writer
                          Flavio Copes         Flavio is a Full Stack Developer
                  译者: TigerWFH   a developer
                                      
            ------------------------------------------------------------------------------------------------------------------
            1.2.3.2 Runtime Performance
            ------------------------------------------------------------------------------------------------------------------
            ------------------------------------------------------------------------------------------------------------------
            1.2.3.3 Page Load Performance
            ------------------------------------------------------------------------------------------------------------------
            ------------------------------------------------------------------------------------------------------------------
            1.2.3.4 Fix Memory Problems
            ------------------------------------------------------------------------------------------------------------------
    ----------------------------
    1.3 Web Starter kit
    ----------------------------
    ----------------------------
    1.4 Polymer Starter kit
    ----------------------------
    ----------------------------
    1.5 Service Worker Libraries
    ----------------------------
       
---------------------------------------------------------
How to use the Timeline Tool
---------------------------------------------------------

   